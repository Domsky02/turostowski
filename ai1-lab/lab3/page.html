<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Puzzle Game with Leaflet</title>
    <link rel="stylesheet" href="leaflet-1.8.0/leaflet.css" />
    <script src="leaflet-1.8.0/leaflet-src.js"></script>
    <script src="leaflet-1.8.0/leaflet-providers.js"></script>
    <script src="leaflet-1.8.0/leaflet-image.js"></script>

    <style>
        #map {
            width: 600px;
            height: 300px;
            border: 1px solid black;
        }

        #puzzle-container {
            position: relative;
            width: 600px;
            height: 300px;
            margin-top: 20px;
            border: 1px solid black;
        }

        .puzzle-piece {
            position: absolute;
            width: 150px;
            height: 75px;
            cursor: pointer;
            border: 1px solid #999;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <button id="getLocation">Get Current Location</button>
    <button id="saveButton">Generate Puzzle</button>
    <div id="puzzle-container"></div>

    <script>
        let map = L.map('map').setView([53.430127, 14.564802], 18);
        L.tileLayer.provider('Esri.WorldImagery').addTo(map);
        const img = new Image();
        const canvas = document.createElement('canvas');
        const stage = canvas.getContext('2d');
        let pieces = [];
        let puzzleWidth;
        let puzzleHeight;
        let pieceWidth;
        let pieceHeight;
        let currentPiece;
        let currentDropPiece;
        let mouse;

        document.getElementById("getLocation").addEventListener("click", function(event) {
            if (!navigator.geolocation) {
                console.log("No geolocation.");
            }

            navigator.geolocation.getCurrentPosition(position => {
                console.log(position);
                let lat = position.coords.latitude;
                let lon = position.coords.longitude;

                map.setView([lat, lon]);
            }, positionError => {
                console.error(positionError);
            });
        });

        document.getElementById("saveButton").addEventListener("click", function() {
            console.log("Save button clicked");
            if (typeof leafletImage !== 'function') {
                console.error("leafletImage is not defined");
                return;
            }
            leafletImage(map, function (err, imgCanvas) {
                if (err) {
                    console.error("Error creating image:", err);
                    return;
                }
                console.log("Image created successfully");
                img.src = imgCanvas.toDataURL();
                img.onload = function() {
                    initPuzzle(imgCanvas);
                };
            });
        });

        function initPuzzle(canvas) {
            pieces = [];
            mouse = { x: 0, y: 0 };
            currentPiece = null;
            currentDropPiece = null;
            puzzleWidth = canvas.width;
            puzzleHeight = canvas.height;
            pieceWidth = Math.floor(puzzleWidth / 4); 
            pieceHeight = Math.floor(puzzleHeight / 4);

            setCanvas();
            buildPieces();
        }

        function setCanvas() {
            canvas.width = puzzleWidth;
            canvas.height = puzzleHeight;
            canvas.style.border = "1px solid black";
            document.getElementById('puzzle-container').appendChild(canvas);
        }

        function buildPieces() {
            let i;
            let piece;
            let xPos = 0;
            let yPos = 0;

            for (i = 0; i < 16; i++) {
                piece = {};
                piece.sx = xPos;
                piece.sy = yPos;
                pieces.push(piece);
                xPos += pieceWidth;
                if (xPos >= puzzleWidth) {
                    xPos = 0;
                    yPos += pieceHeight;
                }
            }
            shufflePuzzle();
        }

        function shufflePuzzle() {
            pieces = shuffleArray(pieces);
            let xPos = 0;
            let yPos = 0;

            stage.clearRect(0, 0, puzzleWidth, puzzleHeight);

            for (const piece of pieces) {
                piece.xPos = xPos;
                piece.yPos = yPos;
                stage.drawImage(img, piece.sx, piece.sy, pieceWidth, pieceHeight, xPos, yPos, pieceWidth, pieceHeight);
                stage.strokeRect(xPos, yPos, pieceWidth, pieceHeight);
                xPos += pieceWidth;
                if (xPos >= puzzleWidth) {
                    xPos = 0;
                    yPos += pieceHeight;
                }
            }
            document.onpointerdown = onPuzzleClick;
        }

        function checkPieceClicked() {
            for (const piece of pieces) {
                if (mouse.x < piece.xPos || mouse.x > piece.xPos + pieceWidth || mouse.y < piece.yPos || mouse.y > piece.yPos + pieceHeight) {

                } else {
                    return piece;
                }
            }
            return null;
        }

        function updatePuzzle(e) {
            currentDropPiece = null;

            if (e.layerX || e.layerX === 0) {
                mouse.x = e.layerX - canvas.offsetLeft;
                mouse.y = e.layerY - canvas.offsetTop;
            } else if (e.offsetX || e.offsetX === 0) {
                mouse.x = e.offsetX - canvas.offsetLeft;
                mouse.y = e.offsetY - canvas.offsetTop;
            }

            stage.clearRect(0, 0, puzzleWidth, puzzleHeight);

            for (const piece of pieces) {
                if (piece === currentPiece) {
                    continue;
                }
                stage.drawImage(img, piece.sx, piece.sy, pieceWidth, pieceHeight, piece.xPos, piece.yPos, pieceWidth, pieceHeight);
                stage.strokeRect(piece.xPos, piece.yPos, pieceWidth, pieceHeight);

                if (currentDropPiece == null) {
                    if (mouse.x < piece.xPos || mouse.x > piece.xPos + pieceWidth || mouse.y < piece.yPos || mouse.y > piece.yPos + pieceHeight) {

                    } else {
                        currentDropPiece = piece;
                        stage.save();
                        stage.globalAlpha = 0.4;
                        stage.fillStyle = "#009900";
                        stage.fillRect(currentDropPiece.xPos, currentDropPiece.yPos, pieceWidth, pieceHeight);
                        stage.restore();
                    }
                }
            }

            stage.save();
            stage.globalAlpha = 0.6;
            stage.drawImage(img, currentPiece.sx, currentPiece.sy, pieceWidth, pieceHeight, mouse.x - pieceWidth / 2, mouse.y - pieceHeight / 2, pieceWidth, pieceHeight);
            stage.restore();
            stage.strokeRect(mouse.x - pieceWidth / 2, mouse.y - pieceHeight / 2, pieceWidth, pieceHeight);
        }

        function onPuzzleClick(e) {
            if (e.layerX || e.layerX === 0) {
                mouse.x = e.layerX - canvas.offsetLeft;
                mouse.y = e.layerY - canvas.offsetTop;
            } else if (e.offsetX || e.offsetX === 0) {
                mouse.x = e.offsetX - canvas.offsetLeft;
                mouse.y = e.offsetY - canvas.offsetTop;
            }

            currentPiece = checkPieceClicked();

            if (currentPiece !== null) {
                stage.clearRect(currentPiece.xPos, currentPiece.yPos, pieceWidth, pieceHeight);
                stage.save();
                stage.globalAlpha = 0.9;
                stage.drawImage(img, currentPiece.sx, currentPiece.sy, pieceWidth, pieceHeight, mouse.x - pieceWidth / 2, mouse.y - pieceHeight / 2, pieceWidth, pieceHeight);
                stage.restore();
                document.onpointermove = updatePuzzle;
                document.onpointerup = pieceDropped;
            }
        }

        function pieceDropped(e) {
            document.onpointermove = null;
            document.onpointerup = null;

            if (currentDropPiece !== null) {
                let tmp = { xPos: currentPiece.xPos, yPos: currentPiece.yPos };
                currentPiece.xPos = currentDropPiece.xPos;
                currentPiece.yPos = currentDropPiece.yPos;
                currentDropPiece.xPos = tmp.xPos;
                currentDropPiece.yPos = tmp.yPos;
            }

            resetPuzzleAndCheckWin();
        }

        function resetPuzzleAndCheckWin() {
            stage.clearRect(0, 0, puzzleWidth, puzzleHeight);
            let gameWin = true;

            for (const piece of pieces) {
                stage.drawImage(img, piece.sx, piece.sy, pieceWidth, pieceHeight, piece.xPos, piece.yPos, pieceWidth, pieceHeight);
                stage.strokeRect(piece.xPos, piece.yPos, pieceWidth, pieceHeight);

                if (piece.xPos !== piece.sx || piece.yPos !== piece.sy) {
                    gameWin = false;
                }
            }

            if (gameWin) {
                setTimeout(() => { alert("Puzzle completed!"); }, 500);
            }
        }

        function shuffleArray(o) {
            for (let j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
            return o;
        }
    </script>
</body>
</html>
